package ssh

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestAddToConfig_NewFile_Success(t *testing.T) {
	tempDir := t.TempDir()

	entry := ConfigEntry{
		Host:         "github-work",
		User:         "git",
		Hostname:     "github.com",
		IdentityFile: "/path/to/key",
	}

	err := AddToConfig(tempDir, entry)

	assert.NoError(t, err)

	configPath := filepath.Join(tempDir, "config")
	assert.FileExists(t, configPath)

	content, err := os.ReadFile(configPath)
	assert.NoError(t, err)

	configStr := string(content)
	assert.Contains(t, configStr, "# Generated by sshman")
	assert.Contains(t, configStr, "Host github-work")
	assert.Contains(t, configStr, "User git")
	assert.Contains(t, configStr, "HostName github.com")
	assert.Contains(t, configStr, "PreferredAuthentications publickey")
	assert.Contains(t, configStr, "IdentityFile /path/to/key")

	for line := range strings.SplitSeq(configStr, "\n") {
		if strings.HasPrefix(line, "\t") {
			assert.True(t, strings.Contains(line, "User") ||
				strings.Contains(line, "HostName") ||
				strings.Contains(line, "PreferredAuthentications") ||
				strings.Contains(line, "IdentityFile"))
		}
	}
}

func TestAddToConfig_AppendToExisting_Success(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "config")

	existingContent := "# Existing config\nHost existing\n\tUser existing-user\n\tHostName existing.com\n"
	err := os.WriteFile(configPath, []byte(existingContent), 0600)
	require.NoError(t, err)

	entry := ConfigEntry{
		Host:         "gitlab-personal",
		User:         "git",
		Hostname:     "gitlab.com",
		IdentityFile: "/path/to/gitlab/key",
	}

	err = AddToConfig(tempDir, entry)
	assert.NoError(t, err)

	content, err := os.ReadFile(configPath)
	assert.NoError(t, err)

	configStr := string(content)
	assert.Contains(t, configStr, "# Existing config")
	assert.Contains(t, configStr, "Host existing")
	assert.Contains(t, configStr, "User existing-user")
	assert.Contains(t, configStr, "HostName existing.com")

	assert.Contains(t, configStr, "Host gitlab-personal")
	assert.Contains(t, configStr, "User git")
	assert.Contains(t, configStr, "HostName gitlab.com")
	assert.Contains(t, configStr, "IdentityFile /path/to/gitlab/key")
}

func TestAddToConfig_MultipleEntries_Success(t *testing.T) {
	tempDir := t.TempDir()

	entries := []ConfigEntry{
		{
			Host:         "github-work",
			User:         "git",
			Hostname:     "github.com",
			IdentityFile: "/path/to/work/key",
		},
		{
			Host:         "gitlab-personal",
			User:         "git",
			Hostname:     "gitlab.com",
			IdentityFile: "/path/to/personal/key",
		},
		{
			Host:         "server-production",
			User:         "deploy",
			Hostname:     "server.example.com",
			IdentityFile: "/path/to/server/key",
		},
	}

	for _, entry := range entries {
		err := AddToConfig(tempDir, entry)
		assert.NoError(t, err)
	}

	configPath := filepath.Join(tempDir, "config")
	content, err := os.ReadFile(configPath)
	assert.NoError(t, err)

	configStr := string(content)

	assert.Contains(t, configStr, "Host github-work")
	assert.Contains(t, configStr, "Host gitlab-personal")
	assert.Contains(t, configStr, "Host server-production")

	assert.Contains(t, configStr, "IdentityFile /path/to/work/key")
	assert.Contains(t, configStr, "IdentityFile /path/to/personal/key")
	assert.Contains(t, configStr, "IdentityFile /path/to/server/key")

	assert.Contains(t, configStr, "HostName github.com")
	assert.Contains(t, configStr, "HostName gitlab.com")
	assert.Contains(t, configStr, "HostName server.example.com")

	generatedCount := strings.Count(configStr, "# Generated by sshman")
	assert.Equal(t, 3, generatedCount)
}

func TestAddToConfig_InvalidSSHPath_Error(t *testing.T) {
	invalidPath := "/nonexistent/path"

	entry := ConfigEntry{
		Host:         "test-host",
		User:         "test-user",
		Hostname:     "test.com",
		IdentityFile: "/path/to/key",
	}

	err := AddToConfig(invalidPath, entry)

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to create SSH config file")
}
